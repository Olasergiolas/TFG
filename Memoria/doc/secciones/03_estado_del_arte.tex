\chapter{Estado del arte}
\label{estado_del_arte}
Tradicionalmente, en el fuzzing orientado a dispositivos IoT no se han aplicando técnicas
específicas para este tipo de dispositivos, es decir, se asemejaba bastante al fuzzing de caja negra 
comúnmente encontrado a la hora de fuzzear servicios web mediante la mutación de peticiones.
Este tipo de fuzzers caracterizados por no tener en cuenta el feedback del objetivo para la mutación de
inputs son conocidos como ''dumb fuzzers'' y presentan un flujo de ejecución simple el cual comienza 
con la mutación de un input válido.
A partir de ahí este input mutado es utilizado como parámetro del objetivo a fuzzear, si el 
objetivo (web, binario, etc.) produce un timeout o crashea el fuzzer registra el input que 
ha provocado este comportamiento y si el funcionamiento del objetivo es correcto, se ignora 
la información proporcionada por este y se vuelve a empezar. Dentro del dumb fuzzing hay también
distintos niveles de complejidad, algunos autores proponen ''random fuzzers'' extremadamente básicos que 
llevan a cabo sus modificaciones al input de forma completamente aleatoria. Este enfoque, utilizado por 
herramientas como\cite{zzuf} sigue la filosofía que dió lugar originalmente al fuzzing en 
los años 80 de la mano de Barton Miller\cite{Miller1990}. Modificar inputs de forma completamente aleatoria
ejemplifica el principal problema del ''dumb fuzzing'', la baja cobertura de código. Para conseguir encontrar 
el mayor número de fallos en el código, es necesario intentar ejecutar la mayor parte de este posible. Cuando 
un input está siendo generado de manera completamente aleatoria, es bastante probable que este no cumpla con
ciertas comprobaciones que el software realice sobre el formato del input. Esto provoca que el input sea descartado 
de manera prematura en la ejecución del software y no se lleguen a alcanzar secciones críticas de código.
Con el objetivo de intentar hacer frente a este reto, otros autores proponen lo que es 
conocido como ''Mutation-based fuzzing'' donde aún aplicando todavía un enfoque de caja negra, se infiere
información sobre el input original a partir de la identificación de patrones y se aplican heurísticas para generar
nuevas mutaciones. Estas heurísticas pueden ser modificables en tiempo de ejecución como hace Radamsa\cite{radamsa}
para conseguir una mayor tasa de éxito de cara a encontrar vulnerabilidades. Esta herramienta ejemplifica que incluso 
un buen fuzzer de caja negra es capaz de identificar de forma efectiva vulnerabilidades críticas en productos comerciales 
ampliamente utilizados como Cisco AnyConnect, Mozilla Firefox o Google Chrome.

Otros fuzzers de caja negra categorizados 
como ''Generation-based fuzzers''\cite{Felderer2016} van un paso más allá y utilizan diccionarios o modelos para solo 
mutar determinados campos de forma que se maximice el número de inputs ''válidos'' generados para la aplicación a fuzzear. Esto es de 
especial interés en aplicaciones que utilizan datos con una sintaxis especialmente compleja o verbose como HTML, SQL o XML.
Boofuzz\cite{boofuzz} es un fuzzer que implementa esta idea permitiendo al usuario crear scripts de Python en los que 
se defina un formato a seguir para el input y los campos de información que pueden ser fuzzeados sin dar lugar a inputs 
inválidos. Usando esta herramienta, el equipo de ''Security for Everyone'' descubrió un 0-day (CVE-2020-29596)\cite{securityforeveryone}
en MiniWeb HTTP server, un servidor HTTP básico orientado a dispositivos empotrados por su bajo uso de recursos.
Xiaotao et al.\cite{snipuzz} proponen una técnica [TBD completar]

En la búsqueda por conseguir una mayor cobertura de código, se pasa de un enfoque de caja negra a enfoques de caja blanca y caja gris.
El primero gira entorno a la idea de generar binarios instrumentados a partir del código fuente original. De esta forma, un compilador 
especial inserta código adicional encargado de reportar al fuzzer qué secciones de código exactamente han sido ejecutada para qué inputs.
Aunque esta es la forma más popular de realizar fuzzing de binarios en la actualidad junto a herramientas como AFL++ o Honggfuzz, su
aplicación orientada al internet de las cosas no es viable en la mayoría de casos ya que como se comentó en ''\nameref{introduccion}''
los componentes software utilizados en firmware IoT no suelen ser de código abierto.\bigskip

Es por ello que un enfoque como el fuzzing de caja gris resulta mucho más atractivo cuando se busca fuzzear binarios de los cuales no se 
posee el código fuente y se quiere hacerlo de manera más sofisticada que en el ''dumb fuzzing'', utilizando feedback para mejorar la mutación
de inputs. En este caso, los fuzzers obtienen dicho feedback sin necesidad de instrumentar el código fuente original.
Es decir, observan distintos parámetros de la ejecución del software a fuzzear para obtener información a modo de feedback que pueda ayudarles 
a conseguir una mayor cobertura de código. El principal reto de los fuzzers de caja gris supone el determinar cómo obtener feedback que pueda 
ser indicativo del estado interno de la ejecución del software objetivo. 

[TBD Necesidad de mejorar resultados -> Grey-box fuzzing -> obtener info -> instrumentar estáticamente difícil -> soluciones como 
reinstrumentación de binarios, fuzzing híbrido, emulación (y sanitizers), fuzzing en el dispositivo con JTAG,..]

[TBD incluir algunas vulnerabilidades que han sacado los fuzzers citados]

[TBD ventajas y 
desventajas del dumb fuzzing, enganchas con las ventajas que supone el poder obtener feedback 
y comenta que esto es especialmente difícil en el fuzzing IoT]

[TBD Cuando se habla de fuzzing orientado a dispositivos IoT todas las técnicas y métodos para llevarlo 
a cabo suelen enfoque emulación, en hardware o híbrido]