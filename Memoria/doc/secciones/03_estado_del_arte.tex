\chapter{Estado del arte}
\label{estado_del_arte}
Tradicionalmente, en el fuzzing orientado a dispositivos IoT no se han aplicando técnicas
específicas para este tipo de dispositivos, es decir, se asemejaba bastante al fuzzing de caja negra 
comúnmente encontrado a la hora de fuzzear servicios web mediante la mutación de peticiones.
Este tipo de fuzzers conocidos como ''dumb fuzzers'' tratan al software como si de una caja negra se tratase, 
algo que recibe un input y genera un output. El código que se haya alcanzado para procesar el input internamente no es tenido en
cuenta a la hora de modificar los inputs. El fuzzing de caja negra sigue un flujo de ejecución simple el 
cual comienza con la mutación de un input válido.
A partir de ahí este input mutado es utilizado como parámetro del objetivo a fuzzear, si el 
objetivo (web, binario, etc.) produce un timeout o crashea, el fuzzer registra el input que 
ha provocado este comportamiento y si el funcionamiento del objetivo es correcto se vuelve a empezar. Dentro del ''dumb fuzzing'' hay también
distintos niveles de complejidad, algunos autores proponen ''random fuzzers'' extremadamente básicos que 
llevan a cabo sus modificaciones al input de forma completamente aleatoria. Este enfoque utilizado por 
herramientas como\cite{zzuf}, sigue la filosofía que dio lugar originalmente al fuzzing en 
los años 80 de la mano de Barton Miller\cite{Miller1990}. Modificar inputs de forma completamente aleatoria
ejemplifica el principal problema del ''dumb fuzzing'', la baja cobertura de código. Para conseguir encontrar 
el mayor número de fallos en el código, es necesario intentar ejecutar el mayor porcentaje de este posible. Cuando 
un input está siendo generado de manera completamente aleatoria, es bastante probable que este no cumpla con
ciertas comprobaciones que el software realice sobre el formato del input. Esto provoca que el input sea descartado 
de manera prematura en la ejecución del software y no se lleguen a alcanzar secciones críticas de código.
Con el objetivo de intentar hacer frente a este reto, otros autores proponen lo que es 
conocido como ''Mutation-based fuzzing'' donde aún aplicando todavía un enfoque de caja negra, se infiere
información sobre el input original a partir de la identificación de patrones y se aplican heurísticas para generar
nuevas mutaciones. Estas heurísticas pueden ser modificables en tiempo de ejecución como hace Radamsa\cite{radamsa}
para conseguir una mayor tasa de éxito de cara a encontrar vulnerabilidades. Esta herramienta ejemplifica que incluso 
un buen fuzzer de caja negra es capaz de identificar de forma efectiva vulnerabilidades críticas en productos comerciales 
ampliamente utilizados como Cisco AnyConnect, Mozilla Firefox o Google Chrome.

Otros fuzzers de caja negra categorizados 
como ''Generation-based fuzzers''\cite{Felderer2016} van un paso más allá y utilizan diccionarios o modelos para solo 
mutar determinados campos de forma que se maximice el número de inputs ''válidos'' generados para la aplicación a fuzzear. Esto es de 
especial interés en aplicaciones que utilizan datos con una sintaxis especialmente compleja o verbose como HTML, SQL o XML.
Boofuzz\cite{boofuzz} es un fuzzer que implementa esta idea permitiendo al usuario crear scripts de Python en los que 
se defina un formato a seguir para el input y los campos de información que pueden ser fuzzeados sin dar lugar a inputs 
inválidos. Usando esta herramienta, el equipo de ''Security for Everyone'' descubrió un 0-day (CVE-2020-29596)\cite{securityforeveryone}
en MiniWeb HTTP server, un servidor HTTP básico orientado a dispositivos empotrados por su bajo uso de recursos.
Xiaotao et al.\cite{snipuzz} proponen ''Snipuzz'', una técnica de fuzzing de caja negra orientada a IoT en la que el fuzzer es capaz de obtener feedback 
de las respuestas que devuelve el dispositivo. La idea principal es poder deducir qué código ha sido ejecutado internamente en base a 
la respuesta obtenida al realizar una petición, aunque esto suponga depender de que el fabricante utilice mensajes de respuesta descriptivos.
Gracias a esta información adicional, ''Snipuzz'' es capaz de identificar qué rol cumple cada 
byte de un input y cómo afecta su modificación a la respuesta del dispositivo. Otros autores hacen frente al reto de conseguir generar inputs 
válidos a través de la invocación de métodos internos de las propias aplicaciones móviles de los fabricantes de dispositivos IoT para generar los 
inputs que enviar al dispositivo.
Basados en este planteamiento surgen ''IoTFuzzer''\cite{Chen2018} y ''DIANE''\cite{Redini2021}, dos fuzzers IoT que delegan la creación de mensajes 
a las aplicaciones para smartphone de fabricantes como TP-Link o Belkin diseñadas para gestionar remotamente los dispositivos IoT. 
Se trata de un enfoque interesante a tener en cuenta ya que estas aplicaciones siempre van a generar mensajes que respeten el formato esperado
por el dispositivo receptor. Partiendo de dicho concepto, estos fuzzers analizan automáticamente el código de las apps móviles en busca de secuencias de 
métodos que envíen mensajes al dispositivo y mediante instrumentación dinámica, ejecutan estos métodos cambiando el valor de sus parámetros. La principal diferencia 
entre ambos reside en el componente de la app móvil que toman como punto de partida. ''IoTFuzzer'' parte de los métodos a nivel de interfaz gráfica de la app
para introducir la información mutada de forma similar a como lo haría un usuario real. Dicho planteamiento presenta el inconveniente de que este tipo 
de apps suelen sanitizar el input del usuario, por lo que una gran cantidad de las mutaciones serán descartadas sin siquiera salir de la app móvil.
''DIANE'' soluciona el problema tomando como punto de partida aquellos métodos que sean ejecutados después de la sanitización de los inputs pero antes de
que se realice el envío del mensaje al dispositivo IoT. Por desgracia, las técnicas de fuzzing de caja negra que trabajan sobre el dispositivo IoT
directamente, ya sea haciéndole peticiones o ejecutando código en el hardware, suponen un gran sacrificio respecto a rendimiento ya que un hardware 
tan limitado como el encontrado en dispositivos empotrados nunca será capaz de aportar una alta tasa de ejecuciones/respuestas por segundo, siendo esto un 
factor clave a la hora de reducir el tiempo puede tardar un fuzzer en detectar una vulnerabilidad.

En la búsqueda por solucionar algunos de los problemas del fuzzing de caja negra como su baja eficiencia o su limitada cobertura de código, se 
adoptan enfoques de caja blanca y caja gris. El primero gira entorno a la idea de generar binarios instrumentados a partir del código fuente original. De esta forma, un compilador 
especial inserta código adicional encargado de reportar al fuzzer qué secciones de código exactamente han sido ejecutadas para qué inputs.
Aunque esta es la metodología más popular para realizar fuzzing de binarios en la actualidad utilizando herramientas como AFL++\cite{afl++} o 
Honggfuzz\cite{honggfuzz}, su aplicación orientada al internet de las cosas no es viable en la mayoría de casos ya que como se comentó en 
''\nameref{introduccion}'' los componentes software utilizados en firmware IoT no suelen ser de código abierto, por lo que no pueden ser recompilados 
usando compiladores que instrumenten el código.\bigskip

Es por ello que un enfoque como el fuzzing de caja gris resulta mucho más atractivo cuando se busca conseguir una mayor cobertura de código
al fuzzear binarios de los cuales no se posee el código fuente. En este caso, los fuzzers obtienen feedback sobre el estado interno de la ejecución
del software sin necesidad de instrumentar el código fuente original.
Es decir, observan distintos parámetros de la ejecución del software para obtener información a modo de feedback que pueda ayudarles 
a conseguir una mayor cobertura de código. Conseguir información que pueda ser indicativa del estado interno de la ejecución de un software es
el principal reto de los fuzzers de caja gris. Llevar a cabo este análisis dinámico de software en arquitecturas más comúnmente orientadas a 
propósito general como es x86-64 no es tarea difícil, pero hacerlo sobre plataformas altamente limitadas tanto en recursos como en funcionalidad
puede suponer un reto. De esta forma surge la idea de añadir una capa de abstracción a través de emulación con soluciones basadas en QEMU\cite{qemu}
que permitan realizar instrumentación dinámica de binarios. QEMU es un eficiente emulador de código abierto capaz de correr sistemas operativos y binarios
diseñados para arquitecturas como ARM en otras completamente distintas como x86-64. Aunque en muchas ocasiones el concepto de emular software se asocia a
una gran reducción de rendimiento, es necesario tener en cuenta que un ordenador de propósito general moderno como un portátil o un sobremesa es 
considerablemente más potente que la mayoría de sistemas empotrados, por lo que aún habiendo un mayor overhead en la ejecución el impacto de este es mitigado.
Los resultados de las investigaciones llevadas a cabo por Muench et al.\cite{Muench2018} muestran cómo emulando un sistema empotrado en su totalidad 
se consigue una mejora de rendimiento sobre el hardware original.
Cuando hablamos de técnicas de emulación de sistemas empotrados, podemos aplicar la siguiente clasificación:
\begin{enumerate}[I]
    \item \textbf{User-mode emulation}: Se emula exclusivamente la ejecución del binario que resulte de interés. QEMU evita tener que emular el sistema 
    operativo al completo traduciendo las llamadas al sistema de la aplicación emulada en llamadas al sistema del host. Es por ello que usar este modo 
    solo es factible si tanto el host como el huésped comparten sistema operativo. Herramientas como Qemuafl\cite{qemuafl} consiguen un mayor número de 
    ejecuciones por segundo en comparación con (II), pero por desgracia la ausencia de emulación de ciertos dispositivos hardware puede hacer imposible 
    el correcto funcionamiento del binario que está siendo emulado. Zheng et al.\cite{Zheng2019} destacan que durante sus intentos de emular distintos 
    servidores HTTP, DNS y SSH utilizados en routers comerciales, este modo de QEMU fue incapaz de emular correctamente ninguno de los binarios analizados.
    \item \textbf{System-mode o Full system emulation}: Se trata de una técnica implementada por QEMU en la cual se crea una máquina virtual que emula un 
    sistema al completo, esto incluye CPU, sistema operativo, periféricos hardware, etc. Gracias a esta técnica es posible emular software que puede resultar 
    problemático aplicando (I) debido a posibles dependencias duras sobre otros dispositivos. Un gran número de fuzzers propuestos por diversos autores 
    basan su funcionamiento en este principio debido a que permite alcanzar un balance entre rendimiento y estabilidad. Algunos ejemplos son [TBD ejemplos]
    \item \textbf{Rehosting}: El rehosting\cite{Fasano2021} es un concepto muy similar a (II) pero con la principal diferencia de que no se busca emular el 
    sistema al completo sino solo el mínimo número de componentes necesarios para hacer funcionar un firmware.
    \item \textbf{Unicorn Engine}: Unicorn [TBD añadir referencia] es un framework basado en QEMU que propone un enfoque de emulación ultraligero en el que el elemento único a 
    emular es la CPU. Se diferencia de (I) en que Unicorn no realiza traducción de llamadas al sistema ni gestión de señales POSIX, solo traduce instrucciones 
    máquina de la arquitectura del huésped a instrucciones comprensibles por la CPU del host. Además, proporciona una API intuitiva que facilita 
    considerablemente operaciones necesarias para la instrumentación dinámica de binarios como lecturas/escrituras de memoria y registros, mapeos de memoria o 
    la posibilidad de definir hooks que serán ejecutados al alcanzarse ciertas direcciones de memoria. [TBD Qiling]
    \item \textbf{Augmented process emulation}:
\end{enumerate} 

Como podemos apreciar, además de la clasificación general de técnicas de fuzzing en fuzzing de caja blanca, gris y negra que hemos aplicado para clasificar las 
distintas técnicas que han sido comentadas, es posible clasificarlas también según el medio en el que el código fuzzeado esté siendo ejecutado. Se presentan así 
tres categorías principales de fuzzing IoT:
\begin{itemize}
    \item \textbf{Fuzzing on-device}: El código que se desea fuzzear es ejecutado íntegramente en el dispositivo.
    \item \textbf{Fuzzing mediante emulación}: Se recurre a software de emulación para ejecutar instrucciones máquina de otras arquitecturas además de 
    emular hardware que pueda ser necesario para el correcto funcionamiento del código fuzzeado.
    \item \textbf{Fuzzing híbrido}: Utilizan tanto emulación como el hardware real del dispositivo para la ejecución de código. Ciertas operaciones que 
    tengan una fuerte dependencia en el hardware original pueden ser redirigidas a este manteniendo las ventajas del fuzzing mediante emulación.
\end{itemize}

[Dificultades para extraer firmware, emular ciertos dispositivos, comportamiento no es el mismo...]

[TBD Necesidad de mejorar resultados -> Grey-box fuzzing -> obtener info -> instrumentar estáticamente difícil -> soluciones como 
reinstrumentación de binarios, fuzzing híbrido, emulación (y sanitizers), fuzzing en el dispositivo con JTAG,..]

[TBD añadir tablas y diagramas]